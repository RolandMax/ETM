% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ETM.R
\name{ETM}
\alias{ETM}
\title{Topic Modelling in Embedding Spaces}
\usage{
ETM(
  k = 20,
  embeddings,
  dim = 800,
  activation = c("relu", "tanh", "softplus", "rrelu", "leakyrelu", "elu", "selu",
    "glu"),
  dropout = 0.5,
  vocab = rownames(embeddings)
)
}
\arguments{
\item{k}{the number of topics to extract}

\item{embeddings}{either a matrix with pretrained word embeddings or an integer with the dimension of the word embeddings. Defaults to 50 if not provided.}

\item{dim}{dimension of the variational inference hyperparameter theta (passed on to \code{\link[torch]{nn_linear}}). Defaults to 800.}

\item{activation}{character string with the activation function of theta. Either one of 'relu', 'tanh', 'softplus', 'rrelu', 'leakyrelu', 'elu', 'selu', 'glu'. Defaults to 'relu'.}

\item{dropout}{dropout percentage on the variational distribution for theta (passed on to \code{\link[torch]{nn_dropout}}). Defaults to 0.5.}

\item{vocab}{a character vector with the words from the vocabulary. Defaults to the rownames of the \code{embeddings} argument.}
}
\value{
an object of class ETM which is a torch \code{nn_module} containing o.a
\itemize{
  \item{num_topics: }{the number of topics}
  \item{TODO.: }{TODO.}
}
}
\description{
ETM is a generative topic model combining traditional topic models (LDA) with word embeddings (word2vec). 
It models each word with a categorical distribution whose natural parameter is the inner product between
a word embedding and an embedding of its assigned topic.\cr
The model is fitted using an amortized variational inference algorithm on top of libtorch.
}
\section{Methods}{

\describe{
  \item{\code{get_beta()}}{softmax-transformed inner product of word embedding and topic embeddings}
  \item{\code{fit(TODO)}}{fit the model on a document term matrix}
}
}

\section{Arguments}{

\describe{
 \item{x}{TODO.}
 \item{x}{TODO. In \code{dgCMatrix} format}
}
}

\examples{
library(torch)
library(word2vec)
library(ETM)
data(ng20, package = "ETM")
vocab  <- ng20$vocab
tokens <- ng20$bow_tr$tokens
counts <- ng20$bow_tr$counts

torch_manual_seed(123456789)
model     <- ETM(k = 4, vocab = vocab, dim = 5, embeddings = 25)
model
optimizer <- optim_adam(params = model$parameters, lr = 0.005, weight_decay = 0.0000012)

traindata <- list(tokens = tokens, counts = counts, vocab = vocab)
test1     <- list(tokens = ng20$bow_ts_h1$tokens, counts = ng20$bow_ts_h1$counts, vocab = vocab)
test2     <- list(tokens = ng20$bow_ts_h2$tokens, counts = ng20$bow_ts_h2$counts, vocab = vocab)

out <- model$fit(data = traindata, test1 = test1, test2 = test2, epoch = 4, 
                 optimizer = optimizer, batch_size = 1000, 
                 lr_damping_factor = 4, nonmono = 10)
test <- subset(out$loss, out$loss$batch_is_last == TRUE)
plot(test$epoch, test$loss)

x <- as.matrix(model$parameters$alphas.weight)
x <- as.matrix(model$parameters$rho.weight)
x <- as.matrix(model$get_beta())

terminology <- model$topwords(top_n = 4)
terminology


##
## Toy example with pretrained embeddings
##
library(udpipe)
library(word2vec)
data(brussels_reviews_anno, package = "udpipe")
x          <- subset(brussels_reviews_anno, language \%in\% "nl")
x          <- paste.data.frame(x, term = "lemma", group = "doc_id") 
set.seed(123456789)
model      <- word2vec(x = x$lemma, dim = 15, iter = 20)
embeddings <- as.matrix(model)

dtm <- subset(brussels_reviews_anno, language \%in\% "nl" & upos \%in\% c("NOUN", "ADJ"))
dtm <- document_term_frequencies(dtm, document = "doc_id", term = "lemma")
dtm <- document_term_matrix(dtm)
dtm <- dtm_conform(dtm, columns = rownames(embeddings))

model     <- ETM(k = 8, dim = 100, embeddings = embeddings, dropout = 0.5)
optimizer <- optim_adam(params = model$parameters, lr = 0.005, weight_decay = 0.0000012)

traindata <- as_tokencounts(dtm[-c(1:50), ])
test1     <- as_tokencounts(dtm[1:25, ])
test2     <- as_tokencounts(dtm[26:50, ])
out <- model$fit(data = traindata, test1 = test1, test2 = test2, epoch = 40, 
                 optimizer = optimizer, batch_size = 1000, 
                 lr_damping_factor = 4, nonmono = 10)
plot(out$loss_test)
test <- subset(out$loss, out$loss$batch_is_last == TRUE)
plot(test$epoch, test$loss)
plot(test$epoch, test$nelbo)
terminology <- model$topwords(top_n = 7)
terminology
}
\references{
\url{https://arxiv.org/pdf/1907.04907.pdf}
}
